## Стратегия корректной обработки ресайза (desktop, macOS, iOS 23+)

Этот документ описывает причины текущих проблем со сбросом скролла/артефактами при изменении размера окна и варианты решений. Реализация отложена до завершения миграции; ниже — согласованный план для последующей итерации.

### 1) Симптомы и зоны риска
- Сброс позиции скролла при:
  - переходе полноэкранный ↔ оконный режим;
  - изменении размеров окна в оконном режиме (drag за края).
- На секциях с `ScrollTrigger` и pin/параллакс (услуги, about, контакты/футер) — смещение сильнее и часто уходит в начало страницы.
- На статичных блоках (hero, ALR, галерея) — смещение минимальное.
- Карта Яндекс не ресайзится стабильно после изменения размеров окна.

Основные участники:
- Lenis (плавная прокрутка, внутренний стейт и RAF).
- GSAP ScrollTrigger (авто refresh на resize, pin и расчет прогресса).
- Пинning и собственные вычисления высот/позиционирования (услуги, футер/контакты).
- Яндекс.Карта (требует `fitToViewport()` после resize).

### 2) Почему это происходит
- При resize/fullscreen браузер пересчитывает layout → ScrollTrigger авто-рефрешит триггеры, иногда до восстановления скролла/Lenis, поэтому:
  - прогресс/позиции рассчитываются по старым/промежуточным размерам;
  - у секций с pin «прыгает» базовая высота/offset, что выглядит как сброс скролла.
- Одновременные обработчики (прелоадер, модульные resize-слушатели, карта, триггеры) конкурируют за порядок операций.

### 3) Цели
- Стабильно сохранять позицию скролла при любых изменениях размера/режима.
- Исключить артефакты pin/clipPath/масок.
- Обновлять карту и все триггеры только после стабилизации layout.

### 4) Варианты решений (от «минимальных» к «архитектурным»)

#### Вариант A — «Локальные фиксы» (быстрый, минимально инвазивный)
- Отложить refresh ScrollTrigger для «тяжелых» секций до «после восстановления позиции»:
  - В обработчиках `resize` сначала читать текущий скролл (нативный/Lenis), затем:
    - восстановить позицию (`lenis.scrollTo(value, { immediate: true })` или `window.scrollTo`);
    - только затем `ScrollTrigger.refresh()`; 
    - на модулях с pin/параллакс — пересоздавать триггеры после небольшой задержки (50–150ms).
- Для Яндекс.Карты: вызывать `myMap.container.fitToViewport()` после `ScrollTrigger.refresh()` (через `setTimeout(100–150)`).
- На модулях с pin: убедиться в `invalidateOnRefresh: true` и корректности `pinSpacing` (чаще `true`), чтобы избежать «внезапных» изменений высоты.

Плюсы: быстро, мало изменений. Минусы: вероятны редкие гонки при множественных resize-событиях.

#### Вариант B — «Оркестратор ресайза» (централизовано)
- Ввести единый `ResizeManager` (центр управления событий resize/orientation):
  1) Capture phase: сохранить позицию скролла, временно «заморозить» анимации (опц.: `lenis.stop()`).
  2) Layout phase: дать браузеру закончить пересчет, затем обновить размеры зависимых компонентов (карта и т.п.).
  3) Refresh phase: `ScrollTrigger.refresh()` и пересоздание критичных триггеров (услуги, футер).
  4) Restore phase: вернуть позицию скролла (Lenis immediate), «разморозить» анимации.
- Все модули подписываются на `ResizeManager.onResize(handler)`, при этом менеджер гарантирует порядок шагов (см. «Пайплайн» ниже).

Плюсы: предсказуемый порядок, расширяемость под будущие страницы. Минусы: требует интеграции модулей.

#### Вариант C — «CSS/верстка-стабилизация»
- Для контейнеров pin/clip-path:
  - добавить `contain: layout paint;` на обертки с пином (исолирует пересчет);
  - следить, чтобы высоты секций не «прыгали» от процентов/вьюпорт-единиц на resize (в iOS 15+/23 использовать `svh`/`dvh` или кастомную `--vh`).
- Для футера/контактов:
  - убедиться, что `wrap` имеет стабильные размеры при refresh (минимизировать зависимость от динамического контента).

Плюсы: меньше JS-зависимости. Минусы: не всегда достаточно без JS-оркестрации.

#### Вариант D — «Снижение чувствительности»
- В отключенном состоянии (пока идет resize) временно:
  - упростить анимации (убрать scrub, оставить конечные состояния);
  - отключить pin (рисковый вариант, если UX не критичен на ресайзе).

Плюсы: простота. Минусы: UX деградирует во время ресайза.

### 5) Рекомендуемый пайплайн (если выбираем Вариант B)
Порядок действий `ResizeManager`:
1) onResize (debounce 150–250ms, «склейка» частых событий):
   - readScroll := Lenis.scroll или `window.pageYOffset`.
   - freeze (опц.): `lenis.stop()`; (или просто не останавливать, если хватает immediate).
2) setTimeout(0–50): дать layout устаканиться.
3) components.preUpdate (карта → `fitToViewport()`; прочие компоненты).
4) `ScrollTrigger.refresh()`; модули с pin/параллакс (услуги, футер) — пересоздать триггеры.
5) restoreScroll(readScroll) с `immediate: true`.
6) setTimeout(50–120): final `ScrollTrigger.refresh()` (safety).
7) unfreeze (опц.): `lenis.start()`.

Примечание: на iOS стоит учитывать `window.visualViewport.resize` и `orientationchange` — подписывать `ResizeManager` и туда, обрабатывая по тому же пайплайну.

### 6) Точки интеграции по модулям
- Preloader: оставить только сохранение/восстановление позиции при refresh (не дублировать resize-логику).
- ScrollFlow (контакты/футер): создавать триггеры после `preloaderComplete`; при resize/ориентации — пересоздавать только после restoreScroll.
- ServicesParallax/About: `invalidateOnRefresh: true`, `immediateRender: false` где возможно; пересоздание триггеров через оркестратор.
- Карта: `fitToViewport()` после фазы restore (или между refresh-ами).

### 7) Дополнительные меры
- Глобально ограничить авто-рефреш ScrollTrigger на `resize`:
  - `ScrollTrigger.config({ autoRefreshEvents: 'visibilitychange,DOMContentLoaded,load' })`.
  - Затем триггерить refresh вручную в оркестраторе.
- Использовать `requestAnimationFrame`/микрозадержку между шагами (50–120ms) — снижает вероятность гонок.
- Для высот, зависящих от vh: использовать `svh/dvh` или custom `--vh` с обновлением на resize (особенно для iOS).

### 8) План внедрения (после завершения миграции и тестов)
1) Ввести `ResizeManager` (без изменения поведения модулей) и переключить refresh ScrollTrigger под него.
2) Подписать на него:
   - карта (fitToViewport),
   - ScrollFlow (пересоздание триггеров),
   - ServicesParallax/About (refresh/пересоздание).
3) Провести тесты: 
   - fullscreen ↔ windowed; drag resize; iPad iOS 23 (visualViewport); Safari/Chrome/Firefox.
4) По результатам — точечно добавить CSS-стабилизацию (`contain`, `svh/dvh`, `--vh`).

### 9) Итог
Корневая причина — гонки между восстановлением скролла, авто-refresh ScrollTrigger и пересчетом layout. Любой из описанных вариантов (A–D) улучшит ситуацию; рекомендуем Вариант B (оркестратор) как устойчивое архитектурное решение, с началом через малозатратный Вариант A на критичных секциях.


